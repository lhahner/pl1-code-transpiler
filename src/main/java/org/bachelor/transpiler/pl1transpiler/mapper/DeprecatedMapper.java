package org.bachelor.transpiler.pl1transpiler.mapper;

/*
 * Copyright (c) 2023-2024, Lennart Hahner
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.bachelor.transpiler.pl1transpiler.parser.Node;
import org.bachelor.transpiler.pl1transpiler.parser.SimpleNode;
import org.bachelor.transpiler.pl1transpiler.symboltable.SymbolTable;

/**
 * @deprecated
 * The Class Checker is used as a utilization to search the parse-tree
 * generated by the Pl1Parser class for different semantic analysis, e.g.:
 * Type checking or Name checking. 
 * It implements the Depth-In-First Search algorithm in different methods
 * with multiple different search criteria.
 * Other Classes can implement this by inheritance.
 * 
 * {@link https://de.wikipedia.org/wiki/Tiefensuche}
 *
 * @author Lennart Hahner
 */
public class DeprecatedMapper {
	
	/** 
	 * Contains one Node which has a certain criteria 
	 * defined by parameters of one of the search methods.
	 * @see SimpleNode 
	 */
	public SimpleNode foundValue;
	
	/** 
	 * Contains all Node which have a certain criteria 
	 * defined by a parameter of one of the search methods.
	 */
	public ArrayList<SimpleNode> foundNodes = new ArrayList<SimpleNode>();
	
	/** 
	 * Initiates a Stack which is just an Stack-Data-Structure build around an ArrayList.
	 * The stack is used to track the visited values in the Depth-First search algorithm.
	 * @see Stack.
	 */
	Stack<String> tracker = new Stack<String>();
	
	/** 
	 * Initiates the Symbol-table Module. 
	 * It is used to check certain Identifier during runtime.
	 */
	SymbolTable symbols = new SymbolTable();
	
	/**
	 * @param startNode			When calling this Method outside of itself, this 
	 * 							has to be the first element of a the Parse-Tree.
	 * 							Only when calling recursive this can also be a Child-Node, 
	 * 							not null.
	 * 
	 * @param nodeAttribute		Specifies a certain attribute of a Parse-Tree-Node to search for.
	 * 							@see SimpleNode and check the global variable value, it contains the
	 * 							Node-attribute to search for,
	 * 							not null.
	 * 
	 * @param targetNode		Specifies a certain Node-Name to search for. This String
	 * 							should follow the naming rules for the Parse-Tree generated 
	 * 							by the Pl1Parser Class. The Node-Name are defined either 
	 * 							in the parser.jj file or the Pl1Parser class.
	 */
	public void searchValue(SimpleNode startNode, String nodeAttribute, String targetNode) {
		if (startNode.jjtGetParent() == null) {
			tracker.push(startNode.toString());
			tracker.printStack();
			if(hasTargetNodeAttribute((SimpleNode)startNode, nodeAttribute, targetNode)) {
				this.foundValue = startNode;
			}
			
			if (this.hasChildren(startNode)) {
				for (int i = 0; i < startNode.jjtGetNumChildren(); i++) {
					tracker.push(startNode.jjtGetChild(i).toString());
					tracker.printStack();
					
					if(hasTargetNodeAttribute((SimpleNode)startNode.jjtGetChild(i), nodeAttribute, targetNode)) {
						this.foundValue = (SimpleNode)startNode.jjtGetChild(i);
					}		
					searchValue((SimpleNode) startNode.jjtGetChild(i), nodeAttribute, targetNode);
					tracker.pop();
					tracker.printStack();
				}
			}
			else {
				return;
			}
		}
		else {
			for (int i = 0; i < startNode.jjtGetNumChildren(); i++) {
				tracker.push(startNode.jjtGetChild(i).toString());
				tracker.printStack();
				
				if(hasTargetNodeAttribute((SimpleNode)startNode.jjtGetChild(i), nodeAttribute, targetNode)) {
					this.foundValue = (SimpleNode)startNode.jjtGetChild(i);
				}
				
				if (this.hasChildren(startNode.jjtGetChild(i))) {
					searchValue((SimpleNode) startNode.jjtGetChild(i), nodeAttribute, targetNode);
					tracker.pop();
					tracker.printStack();

				}
				else {
					tracker.pop();
					tracker.printStack();
				}
			}
		}
	}
	
	/**
	 * This method searches for specific node inside the parse-tree. It will place
	 * the found Nodes inside the global ArrayList foundValues. Since there can be 
	 * multiple matches, it appends each found value in the ArrayList. To
	 * use this method inside the Checker Module, the class needs to inherit from
	 * the checker class.
	 *
	 * @param startNode		Calling this Method outside of itself, this 
	 * 						has to be the first element of a the Parse-Tree.
	 * 						Only when calling recursive this can also be a Child-Node, 
	 * 						should be not null.
	 * 
	 * @param targetNode	Specifies a certain Node-Name to search for. This String
	 * 						should follow the naming rules for the Parse-Tree generated 
	 * 						by the Pl1Parser Class. The Node-Name are defined either 
	 * 						in the parser.jj file or the Pl1Parser class,
	 * 						should be not null.
	 */
	public void searchNode(SimpleNode startNode, String targetNode) {
		if (startNode.jjtGetParent() == null) {
			tracker.push(startNode.toString());
			tracker.printStack();
			if(isTargetNode((SimpleNode)startNode, targetNode)) {
				this.foundNodes.add(startNode);
			}
			
			if (this.hasChildren(startNode)) {
				for (int i = 0; i < startNode.jjtGetNumChildren(); i++) {
					tracker.push(startNode.jjtGetChild(i).toString());
					tracker.printStack();
					
					if(isTargetNode((SimpleNode)startNode.jjtGetChild(i), targetNode)) {
						this.foundNodes.add((SimpleNode)startNode.jjtGetChild(i));
					}		
					searchNode((SimpleNode) startNode.jjtGetChild(i), targetNode);
					tracker.pop();
					tracker.printStack();
				}
			}
			else {
				return;
			}
			tracker.pop();
		}
		else {
			for (int i = 0; i < startNode.jjtGetNumChildren(); i++) {
				tracker.push(startNode.jjtGetChild(i).toString());
				tracker.printStack();
				
				if(isTargetNode((SimpleNode)startNode.jjtGetChild(i), targetNode)) {
					this.foundNodes.add((SimpleNode)startNode.jjtGetChild(i));
				}
				
				if (this.hasChildren(startNode.jjtGetChild(i))) {
					searchNode((SimpleNode) startNode.jjtGetChild(i), targetNode);
					tracker.pop();
					tracker.printStack();

				}
				else {
					tracker.pop();
					tracker.printStack();
				}
			}
		}
	}

	/**
	 * Checks if a Node has children by checking the number of
	 * children provided by the SimpleNode class. 
	 *
	 * @param nodeToCheck		Node that should be checked for children Nodes.
	 * @return 					True if number of Children is larger than 0.
	 */
	public boolean hasChildren(Node nodeToCheck) {
		if (nodeToCheck.jjtGetNumChildren() > 0) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * This Method checks if the Node is the target Node with the required attribute.
	 * In this method both, the attribute and the Node-Name must match. 
	 * 
	 * @param checkingNode			The Node that should be checked if it meets the provided requirements
	 * 								provided by the two other parameters.
	 * 
	 * @param requiredAttribute		The attribute the node must provide to meet the requirements for a match.
	 * 
	 * @param targetNode			The expected name of the Node. The Names of the Nodes are defined by 
	 * 								the expression methods in parser.jj or Pl1Parser class. Only 
	 * 								Names that are specified there can result in a match.
	 * 
	 * @return true if the parameter has the required value of required Attribute 
	 * and is has the name of the parameter targetNode, if not false.
	 */
	public boolean hasTargetNodeAttribute(SimpleNode checkingNode, String requiredAttribute, String targetNode) {
		if(checkingNode.jjtGetValue() != null && checkingNode.jjtGetValue().toString().equals(requiredAttribute) && checkingNode.toString().equals(targetNode)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * Checks if the currentNode has the same name as provided in parameter targetNode.
	 *
	 * @param checkingNode		The Node that should be checked if it meets the provided requirements
	 * 							provided by the two other parameters.
	 * 
	 * @param targetNode		The expected name of the Node. The Names of the Nodes are defined by 
	 * 							the expression methods in parser.jj or Pl1Parser class. Only 
	 * 							Names that are specified there can result in a match.
	 * 
	 * @return  true if the parameter has the name of the parameter targetNode, if not false.
	 */
	public boolean isTargetNode(SimpleNode checkingNode, String targetNode) {
		if(checkingNode != null && checkingNode.toString().equals(targetNode)) {
			return true;
		}
		else {
			return false;
		}
	}
	
	/**
	 * Frees all Values from LinkList of Class.
	 * This should be called whenever calling one of the search method twice
	 * in the same runtime. If they are not freed, the ArrayList and the variable
	 * globally declared might have wrong values.
	 */
	public void free() {
		this.foundNodes.clear();
		this.foundValue = null;
	}
}
