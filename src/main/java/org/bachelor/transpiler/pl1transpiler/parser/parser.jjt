/**
*@todo: DEBIT, CREDIT, all keys from PictureMapper
**/
options {
  IGNORE_CASE = true;
  //FORCE_LA_CHECK = true;
  LOOKAHEAD = 3;
  //DEBUG_PARSER = true;
  //DEBUG_LOOKAHEAD = true;
  OUTPUT_DIRECTORY = "./";
  STATIC = false;
}

PARSER_BEGIN(Pl1Parser)
package org.bachelor.transpiler.pl1transpiler.parser;

import java.util.ArrayList;
import org.bachelor.transpiler.pl1transpiler.symboltable.*;
import org.bachelor.transpiler.pl1transpiler.lexer.*;

public class Pl1Parser extends Lexer{
  	private static final int DEFAULT = 0;
  	
	//Defines variable level 0...9
	private int hierachie = 0;

	//Defines the scope	
	private int scope = 0;
	
	private String value;
	private String letter;
	private ArrayList<String> length = new ArrayList<String>();
	private SymbolTable symbols = new SymbolTable();
	private ArrayList<String [] > idsAndScopes = new ArrayList<String []>();
	private String[] tmp_idsAndScopes = new String[3];
	
	private int charLength;
	private String number;
	private String stringLength;
	private String pictureAttribiute;

	public Pl1Parser() {
	}
	/**
	* @returns The Picture-Expressions from the users input.
	*/
	public String getPictureAttirbute() {
		return this.pictureAttribiute;
	}

	/**
	* @returns Number that specifies the length of the datatype-expression.
	* @param Index of Array required
	*/
	public String getLength(int i) {
		return length.get(i);
	}

	/**
	*@param Number that defines the hierachie of a variable.
	*/
	public void setHierachie(int hierachie) {
		this.hierachie = hierachie;
	}

	/**
	* @returns Number that defines the hierachie of a variable.
	*/
	public int getHierachie() {
		return hierachie;
	}

	/**
	* @param Identifier scope, is one if global and 2 if local.
	*/
	public void setScope(int scope) {
		this.scope = scope;
	}

	/**
	* Inserts Identifier into Symboltable.
	*/
	public void installIds(String[] symbols_tmp) throws ParseException{
	  if(symbols.getBySymbol(symbols_tmp[0]) != null
	  && symbols.getSymbolScope(symbols_tmp[0]) == Integer.parseInt(symbols_tmp[2])) {
	    	throw new ParseException("Identifier already defined.");
	  }
	  else if( Integer.parseInt(symbols_tmp[2]) == DEFAULT) {
	    throw new ParseException("Scope is Default value. Internal Error.");
	  }
	  symbols.insertId(symbols_tmp);
	}
}

PARSER_END(Pl1Parser)

////////////////////////////////////////////////////////////////////////////////
// Lexical structure
////////////////////////////////////////////////////////////////////////////////


TOKEN :
{
  	
 	 < DCL : "DCL" >
	| < DECLARE : "DECLARE" >
	| < PROCEDURE: "PROCEDURE" >
	| < PROC : "PROC" >
	| < DECIMAL : "DECIMAL" >
	| < BINARY : "BINARY" >
	| < DEC : "DEC" >
	| < BIN : "BIN" >
	| < FIXED : "FIXED" >
	| < FLOAT : "FLOAT" >
	| < CHARACTER : "CHARACTER" >
	| < CHAR : "CHAR" >
	| < STATIC : "STATIC" >
	| < INIT : "INIT" >
	| < PTR : "PTR" >
	| < REAL : "REAL" >
	| < VARYING : "VARYING" >
	| < PIC : "PIC" >
	| < PICTURE : "PICTURE" >
	| < COMPLEX : "COMPLEX" >
	| < UNSIGNED : "UNSIGNED" >
	| < SIGNED : "SIGNED" >
	| < AREA : "AREA" >
	| < DIMENSION : "DIMENSION" >
	| < ENTRY : "ENTRY" >
	| < FILE : "FILE" >
	| < FORMAT : "FORMAT" >
	| < GRAPHIC : "GRAPHIC" >
	| < HANDLE : "HANDLE" >
	| < LABEL : "LABEL" >
	| < LOCATES : "LOCATES" >
	| < NONVARYING : "NONVARYING" >
	| < OFFSET : "OFFSET" >
	| < ORDINAL : "ORDINAL" >
	| < POINTER : "POINTER" >
	| < PRECISION : "PRECISION" >
	| < RETURNS : "RETURNS" >
	| < STRUCTURE : "STRUCTURE" >
	| < TASK : "TASK" >
	| < TYPE : "TYPE" >
	| < UNION : "UNION" >
	| < VARYING4 : "VARYING4" >
	| < VARYINGZ : "VARYINGZ" >
	| < WIDECHAR : "WIDECHAR" >
	| < WIDEPIC : "WIDEPIC" >
	| < ABNORMAL : "ABNORMAL" >
	| < ALIGNED : "ALIGNED" >
	| < ASSIGNABLE : "ASSIGNABLE" >
	| < AUTOMATIC : "AUTOMATIC" >
	| < BASED : "BASED" >
	| < BIGENDIAN : "BIGENDIAN" >
	| < BUFFERED : "BUFFERED" >
	| < BUILTIN : "BUILTIN" >
	| < BYADDR : "BYADDR" >
	| < BYVALUE : "BYVALUE" >
	| < CONDITION : "CONDITION" >
	| < CONNECTED : "CONNECTED" >
	| < CONTROLLED : "CONTROLLED" >
	| < DEFINED : "DEFINED" >
	| < DIMACROSS : "DIMACROSS" >
	| < DIRECT : "DIRECT" >
	| < ENVIRONMENT : "ENVIRONMENT" >
	| < EXCLUSIVE : "EXCLUSIVE" >
	| < EXTERNAL : "EXTERNAL" >
	| < GENERIC : "GENERIC" >
	| < HEXADEC : "HEXADEC" >
	| < IEEE : "IEEE" >
	| < INDFOR : "INDFOR" >
	| < INITIAL : "INITIAL" >
	| < INONLY : "INONLY" >
	| < INOUT : "INOUT" >
	| < INPUT : "INPUT" >
	| < INTERMAL : "INTERMAL" >
	| < KEYED : "KEYED" >
	| < LIKE : "LIKE" >
	| < LIST : "LIST" >
	| < LITTLEENDIAN : "LITTLEENDIAN" >
	| < NONASSIGNABLE : "NONASSIGNABLE" >
	| < NONCONNECTED : "NONCONNECTED" >
	| < NORMAL : "NORMAL" >
	| < OPTIONAL : "OPTIONAL" >
	| < OPTIONS : "OPTIONS" >
	| < OUTONLY : "OUTONLY" >
	| < OUTPUT : "OUTPUT" >
	| < PARAMETER : "PARAMETER" >
	| < POSITION : "POSITION" >
	| < PRINT : "PRINT" >
	| < RECORD : "RECORD" >
	| < SEQUENTIAL : "SEQUENTIAL" >
	| < STREAM : "STREAM" >
	| < UNALIGNED : "UNALIGNED" >
	| < UNBUFFERED : "UNBUFFERED" >
	| < UPDATE : "UPDATE" >
	| < VALUE : "VALUE" >
	| < VARIABLE : "VARIABLE" >
	| < XMLATTR : "XMLATTR" >
	| < XMLOMIT : "XMLOMIT" >
	| < END: "END" >
	| < BIT : "BIT" >
	| < ASSEMBLER : "ASSEMBLER" >
	| < COBOL : "COBOL" >
	| < FORTRAN : "FORTRAN" >
	| < MAIN : "MAIN" >
	| < NOEXECOPS : "NOEXECOPS" >
	| < NOCHARGRAPHIC : "NONCHARGRAPHIC" >
	| < CHARGRAPHIC : "CHARGRAPHIC" >
	| < NOCMPAT : "NOCMPAT" >
	| < CMPAT : "CMPAT" >
	| < DESCRIPTOR : "DESCRIPTOR" >
	| < NODESCRIPTOR : "NODESCRIPTOR" >
	| < FORMALIEN : "FORMALIEN" >
	| < LINKAGE : "LINKAGE" >
	| < NOINLINE : "NOINLINE" >
	| < INLINE : "INLINE" >
	| < ORDER : "ORDER" >
	| < REORDER : "REORDER" >
	| < IRREDUCIBLE : "IRREDUCIBLE" >
	| < REDUCABLE : "REDUCABLE" >
	| < REETRANT : "REETRANT" >
	| < RETCODE : "RETCODE" >
	| < WINMAIN : "WINMAIN" >
	| < RECURSIVE : "RECURSIVE" >
	| < CALL : "CALL" >
	| < RETURN : "RETURN" >
	| < GOTO : "GO TO" >
	| < STOP : "STOP" >
	| < EXIT : "EXIT" >
	| < SET : "SET" >
	| < TITLE : "TITLE" >
	| < FETCH: "FETCH" >
	| < RELEASE : "RELEASE" >
	| < RESERVES : "RESERVES" >
	| < PACKAGE : "PACKAGE" >
	| < EXPORTS : "EXPORTS" >
	| < BEGIN : "BEGIN" >
	| < IF : "IF" >
	| < ELSE : "ELSE" >
	| < THEN : "THEN" >
	| < TO : "TO" >
	| < BY : "BY" >
	| < REPEAT : "REPEAT" >
	| < UPTHRU : "UPTHRU" >
	| < DOWNTHRU : "DOWNTHRU" >
	| < DO : "DO" >
	| < LOOP : "LOOP" >
	| < WHILE : "WHILE" >
	| < UNTIL : "UNTIL" >
	| < DISPLAY : "DISPLAY" >
	| < REPLAY : "REPLAY" >
	| < MINUSCHAR: "-" >
	| < GT : ">" >
	| < LT : "<" >
	| < PLUS : "+" >
	| < COMPLT : "¬"< LT > >
	| < LTEQ : < LT >"=" >
	| < EQ : "=" >
	| < COMPEQ: "¬=" >
	| < COMPGT: "¬"< GT > >
	| < AND : "&" >
	| < OR : "||" >
	| < COMMA_SEPARATOR : "," <SPACE_SEPARATOR> >
	| < X : ("X"|"A"|"9"|"Z"|"V"|"*"|"B"|< LT >|< GT >|< MINUSCHAR >|< PLUS >|"E"|"K"|","|"$"|"€"|"/"|"CR"|"DB"|"S")+ >
	| < A : ("A")+ >
	| < V : ("V")+ >
	| < INTEGER : (["0"-"9"])+ >
	| < STRING : "'"((["a"-"z","A"-"Z","0"-"9","_"," ","!"])+)*"'" >
 	| < PL1_WORD: (["a"-"z","A"-"Z","0"-"9"])+ ((<MINUSCHAR> | "_" )+ (["a"-"z","0"-"9"])+ )* >
	| < EOL: "\n" >
	| < SCOPE : (["1"-"9"]) >
	| < PREPROC_COMMENT: "*|" (~["\n","\r"])* >
	
}

SKIP :
{
	< "/*" (~["*"])* "*" (~["/"])* "*/" >
	| < ";" >
	| < SPACE_SEPARATOR : ( <SPACECHAR> | <EOL> )+ >
	| < SPACECHAR: ( " " | "\t" | "\f" | "\r" )+ >
}


/**
* Grammar Expression for a complete PL/I Programm.
**/
SimpleNode program() #PROGRAM :
{}
{  package_()
  {return jjtThis;}
}

void package_() #PACKAGE :
{
  Token t;
  
  }
{
  ([condition_prefix()":"]< PL1_WORD >":"< PACKAGE >[exports()][< RESERVES >"("< PL1_WORD >")"][options()])
  (var_declaration(1)|procedure())*
  (< END >< PL1_WORD >)
}

void exports() #GLOBAL :
{}
{
  < EXPORTS >("(" parameterlist() ")")?
}

/**
* @todo Implement Chapter 17 for condition prefix
**/
void condition_prefix() #CONDITION :
{}
{
  [< AREA >]
}

void procedure() #PROC :
{}
{
    proc_head()
    proc_body()
  	< END >< PL1_WORD >
}

void proc_head() #HEAD :
{}
{    < PL1_WORD >":"(< PROCEDURE >|< PROC >|< BEGIN >)("(" parameterlist() ")")? (returns())?
  (options())? (< RECURSIVE >)?
}

void proc_body() #BODY :
{}
{    (
    var_declaration(2)
    |entry_statement()
    |call()
    |termination()
    |fetch()
    |release()
    |if_statement()< END >
    |do_statement()< END >
    |display_statement()
    |init_statement()
    )*
}

void if_statement() #IF :
{}
{
  < IF >bool_expression()(bool_operation()bool_expression())*
  < THEN >proc_body()
  [< ELSE >
  	proc_body()]
  	
}

void do_statement() #LOOP :
{}
{
  	  < DO >
	(
	  do_type_2()
	| do_type_3() //Not working
	| do_type_4()
	)
}

void do_type_2() #DO :
{}
{
   (< WHILE > bool_expression() [< UNTIL > bool_expression()]proc_body())
 | (< UNTIL >  bool_expression() [< WHILE > bool_expression()]proc_body())
 	
}

/**
* @todo Check again might be wrong
*/
void do_type_3() :
{}
{
  (    (<PL1_WORD > "=" specification())
  | < WHILE > bool_expression() [< UNTIL > bool_expression()]
  | < UNTIL >  bool_expression() [< WHILE > bool_expression()]
    )
}

void do_type_4() :
{}
{
  (< LOOP >)
}

/**
* @todo Check again might be wrong.
*/
void specification() :
{}
{
  bool_expression()
  (    (< TO >bool_expression()[< BY >bool_expression()])
  | (< BY >bool_expression()[< TO >bool_expression()])
  | (< REPEAT >bool_expression())
  | (< UPTHRU >bool_expression())
  | (< DOWNTHRU >bool_expression())
  )
}

void bool_expression() #BOOL :
{}
{
  (("(")*< PL1_WORD >(bool_operation() (< PL1_WORD >(")")* (bool_operation() < PL1_WORD >(")")*)*))*)
}

void bool_operation() #OP :
{}
{
  (    < MINUSCHAR >
	| < GT >
	| < LT >
	| < PLUS >
	| < COMPLT >
	| < LTEQ >
	| < EQ >
	| < COMPEQ >
	| < COMPGT >
	| < AND >
	| < OR >)*
}

void entry_statement() #ENTRY :
{}
{
  < PL1_WORD >":"< ENTRY >("("parameterlist()")")? (returns())? (options())?
}

void display_statement() #DISPLAY:
{}
{
  < DISPLAY >"("((< STRING >|< PL1_WORD >)*)")"[< REPLAY >"("")"]
}

void init_statement() #INIT:
{}
{
  < PL1_WORD >"="(< STRING >|< INTEGER >)*
}

void returns() #RETURNS:
{}
{
	< RETURNS >"(" type() ")"
}

void options() #OPTIONS:
{}
{
   < OPTIONS >"("((< MAIN >(< NOEXECOPS >)?)
   | (< ASSEMBLER >|< COBOL >|< FORTRAN >)
   | (< BYADDR >|< BYVALUE > )
   | (< NOCHARGRAPHIC >|< CHARGRAPHIC >)
   | (< NOCMPAT >|< CMPAT >)
   | (< DESCRIPTOR >|< NODESCRIPTOR >)
   | < FORMALIEN >
   | (< LINKAGE >parameterlist())
   | (< NOINLINE >|< INLINE >)
   | (< ORDER >|< REORDER >)
   | (< IRREDUCIBLE >| < REDUCABLE >)
   | < REETRANT >
   | < RETCODE >
   | < WINMAIN >)")"
}

void call() #CALLS:
{}
{
  < CALL >(< PL1_WORD >|< PL1_WORD >< BUILTIN >)("("parameterlist()")")?
}

void fetch() #FETCH:
{}
{(< FETCH >< PL1_WORD >)fetch_statement()
	
}

void fetch_statement() #STATEMENT:
{}
{    [< SET >"("< PL1_WORD >")"][< TITLE >"(""'"< PL1_WORD >"'"")"][< COMMA_SEPARATOR > fetch_statement()]
}

void release() #RELEASE:
{}
{
  < RELEASE >(< PL1_WORD >[< COMMA_SEPARATOR >])*
}

void termination() #TERMINATE:
{}
{
  (
  return_val()
  |< GOTO >< PL1_WORD >
  |< STOP >
  |< EXIT >)
}

void return_val():
{}
{
  (< RETURN >[< PL1_WORD >|("("parameterlist()")"|< INTEGER >)|"'"< PL1_WORD >"'"])
}

void parameterlist() #PARA :
{}
{
  < PL1_WORD >(< COMMA_SEPARATOR >parameterlist())?
}


/**
* Grammar Expression for a Variable declaration.
**/
void var_declaration(int scope) #VAR :
{this.scope = scope;}
{	  ( < DCL > | < DECLARE > ) 
	  (this.hierachie = hierachie())?
 	   id() ( type()| type() < COMMA_SEPARATOR > |
      (< COMMA_SEPARATOR > minor(this.getHierachie(), scope))*) | minor(this.getHierachie(), scope)
}

/**
* Grammar Expression for a nested Variable Declaration.
**/
void minor(int parentHierachie, int scope) #MINOR :
{this.scope = scope;}
{
	this.hierachie = hierachie() id()
	(type() |  type() < COMMA_SEPARATOR > | ( < COMMA_SEPARATOR > minor(this.getHierachie(), scope))*) 
}

/**
* @return hierachie of the Variable
**/
int hierachie() #HIERACHIE:
{Token t; }
{
	t = < INTEGER >
	{ return Integer.parseInt(t.image); }
}

/**
* Datatype of the Variabledeclaration.
**/
void type() #TYPE :
{}
{
	(	  codedArithmetic() | String() | Locator() | Picture() | File() | Entry()
	) 
}

/**
* Grammar Expression for Entry.
**/
void Entry() #Entry :
{}
{
  < ENTRY > [< RETURNS >]
}

/**
* Grammar Expression for a File reader.
**/
void File() #File :
{}
{
  < FILE > < ENVIRONMENT >
  ( Stream() | Record()) (Input() | Output() | Update())
  (Sequential() | Direct()) (Buffered() | Unbuffered()) < KEYED >< PRINT >
}

void Stream() #Stream :
{}
{
  < STREAM >
}

void Record() #Record :
{}
{
  < RECORD >
}

void Input() #Input :
{}
{
  < INPUT >
}

void Output() #Output :
{}
{
  < OUTPUT >
}

void Update() #Update :
{}
{
  <UPDATE >
}

void Sequential() #Sequential :
{}
{
  <SEQUENTIAL >
}

void Direct() #Direct :
{}
{
  < DIRECT >
}

void Buffered() #Buffered :
{}
{
  < BUFFERED >
}

void Unbuffered() #Unbuffered :
{}
{
  < UNBUFFERED >
}

/**
* Grammar Expression for a Picture Expression.
**/
String Picture() #PictureExpression :
{ String t; }
{
  (Pic() | Widepic()) [Real() | Complex() ] t = PictureAttribute() [< VALUE > ]
  { return pictureAttribiute = t; }
}

void Pic() #Picture :
{}
{
  ( < PIC > | < PICTURE > )
}

void Widepic() #Widepic :
{}
{
  < WIDEPIC >
}

String PictureAttribute() #PictureAttribute:
{
 String t1 = "";
 String t11 = "";
 
 String t2 = "";
 String t22 = "";
 String t222 = "";
 String t2222 = "";
 
 String t3 = "";
 String t33 = "";
 String t333 = "";

 String t4 = "";

 String t5 = "";
 String t55 = "";
 }
{
  "'" (
	t1 = LengthPicture() (t11 = LetterPicture() | t11 = NumberPicture() ) |
	t2 = LetterPicture() ( t22 = NumberPicture() ( t222 = NumberPicture())*)? t2222 = LetterPicture()
	|	t3 = NumberPicture() t33 = LetterPicture() t333 = NumberPicture() |
	t4 = LetterPicture() |
	(t5 = NumberPicture() ( t55 = NumberPicture())*)?
     )"'"
     { if(t1 != "") return t1 + t11;
     	if(t2 != "") return t2 + t22 + t222 + t2222;
     	if(t3 != "") return t3 + t33 + t333;
     	if(t4 != "") return t4;
     	if(t5 != "") return t5 + t55;
     	 }
}

//| < PIC_REGEX : ("("["0"-"9"]")")?((["0"-"9","X"])+ |(["0"-"9","A"])+ |(["X","0"-"9"])+ )((["A"-"Z","0"-"9"])*) >

String LetterPicture() #PictureLetter :
{Token t;}
{
  ( t = < X > | t = < A > | t = < V >)
  {return t.toString();}
}

String NumberPicture() #Number :
{Token t;}
{
  t = < INTEGER >
  {return t.toString();}
}


String LengthPicture() #PictureLength:
{Token t;
 Token t1;
 Token t2;} 
{
  t = "(" t1 = < INTEGER > t2 = ")"
  {return t.toString() + t1.toString() + t2.toString(); }
}

/**
* Grammar Expression for a Dynamic allocated Datatype.
**/
void Locator() #Locator:
{}
{
	(Pointer() | Offset() | Handle()) < VALUE >< LOCATES >
}

void Pointer() #Pointer:
{}
{
  < POINTER >
}

void Offset() #Offset:
{}
{
  < OFFSET >
}

void Handle() #Handle:
{}
{
  < HANDLE >
}

/**
* Grammar Expression for a String Expression.
**/
void String() #String:
{}
{
  ( Char() | Bit() | Graphic() | Widechar()) (StringAttribute() | StringAttribute() ) [< NONVARYING >] [< VALUE >]
}

void Widechar() #Widechar:
{}
{
  < WIDECHAR >
}

void Graphic() #Graphic:
{}
{
   < GRAPHIC >
}

void Char() #Char:
{}
 {
	(< CHAR > | < CHARACTER >)
 }

void Bit() #Bit:
{}
{
  < BIT >
}

/**
* Grammar Expression for a Arithmetic Datatype.
**/
void codedArithmetic() #Arithmetic:
{}
{
  [ Real()  | Complex()  ]
  [ Float() | Fixed()  ]
  ( Binary() | Decimal() ) (size()) [Signed() | Unsigned() ]
}

void Signed() #Signed:
{}
{
  < SIGNED >
}

void Unsigned() #Unsigned:
{}
{
  < UNSIGNED >
}

void Decimal() #Decimal:
{}
{
   < DECIMAL > 
}

void Fixed() #Fixed:
{}
{
	< FIXED >
}

void Float() #Float:
{}
{
	< FLOAT >
}


void Binary() #Binary:
{}
{
	( < BINARY > | < BIN > )	  
}

void size():
{}
{
  [< PRECISION >](attributes() | attribute())
}

void StringAttribute() #Length:
{Token t;}
{
	("(" t = < INTEGER > ")")
	{this.length.add(t.toString());}
}

void attribute() #Int:
{ Token p;}
{
	("(" p = < INTEGER > ")")
	{this.length.add(p.toString());}
}

void attributes () #Double:
{Token p;
Token q;}
{
	("(" p = < INTEGER > "," q = <  INTEGER > ")")
	{this.length.add(p + "," + q);}

}


void Real() #Real:
{}
{  
	< REAL >
}

void Complex() #Complex:
{}
{
  < COMPLEX >
}
  
/**
* Grammar Expression for a  Identifier.
**/
void id() #Id :
{Token t;}
{
  t=<PL1_WORD>
  {
    String[] tmp = {t.image, this.getHierachie() + "", this.scope + "","id"};
	this.installIds(tmp);
	
	//Reset Hierachie and Scope
	setHierachie(DEFAULT);
	setScope(DEFAULT);
  }
}


