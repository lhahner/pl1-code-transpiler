/**
*@todo: DEBIT, CREDIT, all keys from PictureMapper
**/
options {
  IGNORE_CASE = true;
  //FORCE_LA_CHECK = true;
  LOOKAHEAD = 3;
  //DEBUG_PARSER = true;
  //DEBUG_LOOKAHEAD = true;
  OUTPUT_DIRECTORY = "./";
  STATIC = false;
}

PARSER_BEGIN(Pl1Parser)
package org.bachelor.transpiler.pl1transpiler.parser;

import java.util.ArrayList;
import java.util.HashMap;
import org.bachelor.transpiler.pl1transpiler.symboltable.*;

public class Pl1Parser{
  	private static final int DEFAULT = 0;
  	
	//Defines variable level 0...9
	private int hierachie = 0;

	//Defines the scope	
	private int scope = 0;
	
	private String value;
	private String letter;
	private ArrayList<String> length = new ArrayList<String>();
	private SymbolTable symbols = new SymbolTable();
	private ArrayList<String [] > idsAndScopes = new ArrayList<String []>();
	private String[] tmp_idsAndScopes = new String[3];
	ArrayList<String > paralist = new ArrayList<String >();
	ArrayList<String > typePropreties;
	ArrayList<String > mathExpression = new ArrayList<String >();

	private int charLength;
	private String number;
	private String stringLength;
	private String pictureAttribiute;;
	

	public Pl1Parser() {
	}
	/**
	* @returns The Picture-Expressions from the users input.
	*/
	public String getPictureAttirbute() {
		return this.pictureAttribiute;
	}

	/**
	* @returns Number that specifies the length of the datatype-expression.
	* @param Index of Array required
	*/
	public String getLength(int i) {
		return length.get(i);
	}

	/**
	*@param Number that defines the hierachie of a variable.
	*/
	public void setHierachie(int hierachie) {
		this.hierachie = hierachie;
	}

	/**
	* @returns Number that defines the hierachie of a variable.
	*/
	public int getHierachie() {
		return hierachie;
	}

	/**
	* @param Identifier scope, is one if global and 2 if local.
	*/
	public void setScope(int scope) {
		this.scope = scope;
	}

	/**
	* Inserts Identifier into Symboltable.
	*/
	public void installIds(String[] symbols_tmp) throws ParseException{
	  if(symbols.getBySymbol(symbols_tmp[0]) != null
	  && symbols.getSymbolScope(symbols_tmp[0]) == Integer.parseInt(symbols_tmp[2])) {
	    	throw new ParseException("Identifier already defined.");
	  }
	  else if( Integer.parseInt(symbols_tmp[2]) == DEFAULT) {
	    throw new ParseException("Scope is Default value. Internal Error.");
	  }
	  symbols.insertId(symbols_tmp);
	}
}

PARSER_END(Pl1Parser)

////////////////////////////////////////////////////////////////////////////////
// Lexical structure
////////////////////////////////////////////////////////////////////////////////


TOKEN :
{
  	
 	 < DCL : "DCL" >
	| < DECLARE : "DECLARE" >
	| < PROCEDURE: "PROCEDURE" >
	| < PROC : "PROC" >
	| < DECIMAL : "DECIMAL" >
	| < BINARY : "BINARY" >
	| < DEC : "DEC" >
	| < BIN : "BIN" >
	| < FIXED : "FIXED" >
	| < FLOAT : "FLOAT" >
	| < CHARACTER : "CHARACTER" >
	| < CHAR : "CHAR" >
	| < STATIC : "STATIC" >
	| < INIT : "INIT" >
	| < PTR : "PTR" >
	| < REAL : "REAL" >
	| < VARYING : "VARYING" >
	| < PIC : "PIC" >
	| < PICTURE : "PICTURE" >
	| < COMPLEX : "COMPLEX" >
	| < UNSIGNED : "UNSIGNED" >
	| < SIGNED : "SIGNED" >
	| < AREA : "AREA" >
	| < DIMENSION : "DIMENSION" >
	| < ENTRY : "ENTRY" >
	| < FILE : "FILE" >
	| < FORMAT : "FORMAT" >
	| < GRAPHIC : "GRAPHIC" >
	| < HANDLE : "HANDLE" >
	| < LABEL : "LABEL" >
	| < LOCATES : "LOCATES" >
	| < NONVARYING : "NONVARYING" >
	| < OFFSET : "OFFSET" >
	| < ORDINAL : "ORDINAL" >
	| < POINTER : "POINTER" >
	| < PRECISION : "PRECISION" >
	| < RETURNS : "RETURNS" >
	| < STRUCTURE : "STRUCTURE" >
	| < TASK : "TASK" >
	| < TYPE : "TYPE" >
	| < UNION : "UNION" >
	| < VARYING4 : "VARYING4" >
	| < VARYINGZ : "VARYINGZ" >
	| < WIDECHAR : "WIDECHAR" >
	| < WIDEPIC : "WIDEPIC" >
	| < ABNORMAL : "ABNORMAL" >
	| < ALIGNED : "ALIGNED" >
	| < ASSIGNABLE : "ASSIGNABLE" >
	| < AUTOMATIC : "AUTOMATIC" >
	| < BASED : "BASED" >
	| < BIGENDIAN : "BIGENDIAN" >
	| < BUFFERED : "BUFFERED" >
	| < BUILTIN : "BUILTIN" >
	| < BYADDR : "BYADDR" >
	| < BYVALUE : "BYVALUE" >
	| < CONDITION : "CONDITION" >
	| < CONNECTED : "CONNECTED" >
	| < CONTROLLED : "CONTROLLED" >
	| < DEFINED : "DEFINED" >
	| < DIMACROSS : "DIMACROSS" >
	| < DIRECT : "DIRECT" >
	| < ENVIRONMENT : "ENVIRONMENT" >
	| < EXCLUSIVE : "EXCLUSIVE" >
	| < EXTERNAL : "EXTERNAL" >
	| < GENERIC : "GENERIC" >
	| < HEXADEC : "HEXADEC" >
	| < IEEE : "IEEE" >
	| < INDFOR : "INDFOR" >
	| < INITIAL : "INITIAL" >
	| < INONLY : "INONLY" >
	| < INOUT : "INOUT" >
	| < INPUT : "INPUT" >
	| < INTERMAL : "INTERMAL" >
	| < KEYED : "KEYED" >
	| < LIKE : "LIKE" >
	| < LIST : "LIST" >
	| < LITTLEENDIAN : "LITTLEENDIAN" >
	| < NONASSIGNABLE : "NONASSIGNABLE" >
	| < NONCONNECTED : "NONCONNECTED" >
	| < NORMAL : "NORMAL" >
	| < OPTIONAL : "OPTIONAL" >
	| < OPTIONS : "OPTIONS" >
	| < OUTONLY : "OUTONLY" >
	| < OUTPUT : "OUTPUT" >
	| < PARAMETER : "PARAMETER" >
	| < POSITION : "POSITION" >
	| < PRINT : "PRINT" >
	| < RECORD : "RECORD" >
	| < SEQUENTIAL : "SEQUENTIAL" >
	| < STREAM : "STREAM" >
	| < UNALIGNED : "UNALIGNED" >
	| < UNBUFFERED : "UNBUFFERED" >
	| < UPDATE : "UPDATE" >
	| < VALUE : "VALUE" >
	| < VARIABLE : "VARIABLE" >
	| < XMLATTR : "XMLATTR" >
	| < XMLOMIT : "XMLOMIT" >
	| < END: "END" >
	| < BIT : "BIT" >
	| < ASSEMBLER : "ASSEMBLER" >
	| < COBOL : "COBOL" >
	| < FORTRAN : "FORTRAN" >
	| < MAIN : "MAIN" >
	| < NOEXECOPS : "NOEXECOPS" >
	| < NOCHARGRAPHIC : "NONCHARGRAPHIC" >
	| < CHARGRAPHIC : "CHARGRAPHIC" >
	| < NOCMPAT : "NOCMPAT" >
	| < CMPAT : "CMPAT" >
	| < DESCRIPTOR : "DESCRIPTOR" >
	| < NODESCRIPTOR : "NODESCRIPTOR" >
	| < FORMALIEN : "FORMALIEN" >
	| < LINKAGE : "LINKAGE" >
	| < NOINLINE : "NOINLINE" >
	| < INLINE : "INLINE" >
	| < ORDER : "ORDER" >
	| < REORDER : "REORDER" >
	| < IRREDUCIBLE : "IRREDUCIBLE" >
	| < REDUCABLE : "REDUCABLE" >
	| < REETRANT : "REETRANT" >
	| < RETCODE : "RETCODE" >
	| < WINMAIN : "WINMAIN" >
	| < RECURSIVE : "RECURSIVE" >
	| < CALL : "CALL" >
	| < RETURN : "RETURN" >
	| < GOTO : "GO TO" >
	| < STOP : "STOP" >
	| < EXIT : "EXIT" >
	| < SET : "SET" >
	| < TITLE : "TITLE" >
	| < FETCH: "FETCH" >
	| < RELEASE : "RELEASE" >
	| < RESERVES : "RESERVES" >
	| < PACKAGE : "PACKAGE" >
	| < EXPORTS : "EXPORTS" >
	| < BEGIN : "BEGIN" >
	| < IF : "IF" >
	| < ELSE : "ELSE" >
	| < THEN : "THEN" >
	| < TO : "TO" >
	| < BY : "BY" >
	| < REPEAT : "REPEAT" >
	| < UPTHRU : "UPTHRU" >
	| < DOWNTHRU : "DOWNTHRU" >
	| < DO : "DO" >
	| < LOOP : "LOOP" >
	| < WHILE : "WHILE" >
	| < UNTIL : "UNTIL" >
	| < DISPLAY : "DISPLAY" >
	| < REPLY : "REPLY" >
	| < READ : "READ" >
	| < INTO : "INTO" >
	| < MINUSCHAR: "-" >
	| < DIVIDE : "/" >
	| < MULTIPLY: "*" >
	| < GT : ">" >
	| < LT : "<" >
	| < PLUS : "+" >
	| < COMPLT : "¬"< LT > >
	| < LTEQ : < LT >"=" >
	| < GTEQ : < GT >"=" >
	| < EQ : "=" >
	| < COMPEQ: "¬=" >
	| < COMPGT: "¬"< GT > >
	| < AND : "&" >
	| < OR : "||" >
	| < COMMA_SEPARATOR : ",">
	| < X : ("X"|"A"|"9"|"Z"|"V"|< MULTIPLY >|"B"|< LT >|< GT >|< MINUSCHAR >|< PLUS >|"E"|"K"|","|"$"|"€"|"/"|"CR"|"DB"|"S")+ >
	| < A : ("A")+ >
	| < V : ("V")+ >
	| < INTEGER : (["0"-"9"])+ >
	| < STRING : "'"((["a"-"z","A"-"Z","0"-"9","_"," ","!"])+)*"'" >
 	| < PL1_WORD: (["a"-"z","A"-"Z","0"-"9"])+ ((<MINUSCHAR> | "_" )+ (["a"-"z","0"-"9"])+ )* >
	| < EOL: "\n" >
	| < SCOPE : (["1"-"9"]) >
	| < PREPROC_COMMENT: "*|" (~["\n","\r"])* >
	
}

SKIP :
{
	< "/*" (~["*"])* "*" < STRING > (~["/"])* "*/" >
	| < ";" >
	| < SPACE_SEPARATOR : ( <SPACECHAR> | <EOL> )+ >
	| < SPACECHAR: ( " " | "\t" | "\f" | "\r" )+ >
}


/**
* Grammar Expression for a complete PL/I Programm.
**/
SimpleNode program() #PROGRAM :
{}
{  package_()
  {return jjtThis;}
}

void package_() #PACKAGE :
{
  Token t;
  
  }
{
  ([[< AREA >]":"]id("PACKAGE")":"< PACKAGE >[< EXPORTS >("(" parameterlist() ")")?][< RESERVES >"("< PL1_WORD >")"][options()])
  (var_declaration(1)|procedure())*
  (footer())
}


void footer() #END :
{Token t = null;}
{
  (< END >[t = < PL1_WORD >])
  
  {
    jjtThis.value = t != null ? t.image : "";
  
  }
}

void procedure() #PROC :
{this.scope = 1;}
{
    proc_head()
    proc_body()
  	footer()
}

void proc_head() #HEAD :
{}
{    id("PROC")":"(< PROCEDURE >|< PROC >|< BEGIN >)("(" parameterlist() ")")? (returns())?
  (options())? (< RECURSIVE >)?
}

void proc_body() #BODY :
{}
{    (
    var_declaration(2)
    |entry_statement()
    |call()
    |init_statement()
    |termination()
    |fetch()
    |release()
    |display_statement()
    |read_statement()
    |if_statement()footer()
    |do_statement()footer()
    )*
}

void if_statement() #BRANCH :
{}
{
  < IF >bool_expression()
  < THEN >proc_body()
  [else_statement()]
}

void else_statement() #BRANCH:
{
}
{
	< ELSE >
  	proc_body()
}

void do_statement() #LOOP :
{}
{
  	  < DO >
	(
	   (< WHILE > bool_expression() [until_statement()]proc_body())
 	 | (until_statement() [< WHILE > bool_expression()]proc_body())
	)
}

void until_statement() #UNTIL :
{}
{
  < UNTIL > bool_expression()
  {
  }
}

/**
* @todo Check again might be wrong.
*/
void specification() :
{}
{
  bool_expression()
  (    (< TO >bool_expression()[< BY >bool_expression()])
  | (< BY >bool_expression()[< TO >bool_expression()])
  | (< REPEAT >bool_expression())
  | (< UPTHRU >bool_expression())
  | (< DOWNTHRU >bool_expression())
  )
}

void bool_expression() #BOOL :
{
  ArrayList<String > boolean_expression = new ArrayList<String >();
  Token open_bracket = null;
  Token operand_1 = null;
  Token operator_1 = null;
  
  Token operand_2 = null;
  Token closing_bracket = null;
  Token operator_2 = null;
  
  Token operand_3 = null;
  Token closing_bracket_1 = null;
  Token operator_4 = null;
}
{
 
  ((open_bracket="(")*
  (operand_1=< PL1_WORD >|operand_1=< INTEGER >)(operator_1=bool_operation()
  ((operand_2=< PL1_WORD >|operand_2=< INTEGER >)(closing_bracket=")")*(operator_2=bool_operation()
  (operand_3=< PL1_WORD >|operand_3=< INTEGER >)(closing_bracket_1=")")*)*))*(operator_4=bool_operation()bool_expression())*)
  
  

  {
    if(open_bracket != null) {
		boolean_expression.add(open_bracket.image);
    }
   if(operand_1 != null) {
     boolean_expression.add(operand_1.image);
   }
   if(operator_1 != null) {
     boolean_expression.add(operator_1.image);
   }
   if(operand_2 != null) {
     boolean_expression.add(operand_2.image);
   }
   if(closing_bracket != null) {
		boolean_expression.add(closing_bracket.image);
    }
   if(operator_2 != null) {
     boolean_expression.add(operator_2.image);
   }
   if(operand_3 != null) {
     boolean_expression.add(operand_3.image);
   }
   if(closing_bracket_1 != null) {
		boolean_expression.add(closing_bracket_1.image);
    }
   if(operator_4 != null) {
     boolean_expression.add(operator_4.image);
   }
   jjtThis.value = boolean_expression;
  }
}

Token bool_operation() #OP :
{Token t = null;}
{
  (    t = < MINUSCHAR >
	| t = < GT >
	| t = < LT >
	| t = < PLUS >
	| t = < COMPLT >
	| t = < LTEQ >
	| t = < GTEQ >
	| t = < EQ >
	| t = < COMPEQ >
	| t = < COMPGT >
	| t = < AND >
	| t = < OR >)*

	{
	  return t;
	}
}

void entry_statement() #ENTRY :
{}
{
  < PL1_WORD >":"< ENTRY >("("parameterlist()")")? (returns())? (options())?
}

void display_statement() #DISPLAY:
{
 ArrayList<String > displayValues = new ArrayList<String >();
  //Stores the String that is displayed to the console.
  Token displayString = null;
  //variable to Store User Input.
  Token saveUserInput = null;
 }
{
  < DISPLAY >"("(displayString=< STRING >)")"[< REPLY >"("saveUserInput=< PL1_WORD >")"]

  {
     if(displayString != null) {
		displayValues.add(displayString.image.replaceAll("'", "\""));
    }
    if(saveUserInput != null) {
      displayValues.add(saveUserInput.image);
    }
    jjtThis.value = displayValues;
  }
}

void init_statement() #ASSIGN:
{
  //TODO change to JSON
 String[] assignAttributes = new String[2];
 Token identifier = null;
 Token assignValue = null;
 Token factorial = null;
 }
{
 	(   	identifier=< PL1_WORD >< EQ >(math_expression()|assignValue=< PL1_WORD >|assignValue=< STRING >|assignValue=< INTEGER >["."factorial=< INTEGER >])
    {
      assignAttributes[0] = identifier != null ? identifier.image : "";
      jjtThis.value = assignAttributes;
    }
   	    |(< INIT >"("(assignValue=< STRING >|assignValue=< INTEGER >)")")
 	)
	 {
	   assignAttributes[1] = assignValue != null ? assignValue.image : "";
	   jjtThis.value = assignAttributes;
     }
  {
    assignAttributes[1] = factorial != null ? assignAttributes[1] + "." + factorial.image : assignAttributes[1];
    jjtThis.value = assignAttributes;
  }
}

//{
// (
//   
//    (
//        identifier=< PL1_WORD >< EQ >(math_expression()|assignValue=< PL1_WORD >|assignValue=< STRING >|assignValue=< INTEGER >["."factorial=< INTEGER >])*
// 	)|
// 	(
// 	  < INIT >"("(assignValue=< STRING >|assignValue=< INTEGER >)")")
//)
//	 {
//	   assignAttributes[1] = assignValue != null ? assignValue.image : "";
//	   jjtThis.value = assignAttributes;
//     }
//  {
//    assignAttributes[1] = factorial != null ? assignAttributes[1] + "." + factorial.image : "";
//    jjtThis.value = assignAttributes;
//  }
//}


void math_expression() #CALC:
{
  Token operand_1 = null;
  Token operator_1 = null;
  Token operand_2 = null;
}
{
  	(operand_1=< INTEGER >|operand_1=< PL1_WORD >) (operator_1=< PLUS >|operator_1=< MINUSCHAR >|operator_1=< DIVIDE >|operator_1=< MULTIPLY >)(operand_2=< INTEGER >|operand_2=< PL1_WORD >)
	  {
	    //TODO Only works for one term.
	    jjtThis.value = operand_2 != null ?
	    				operand_1.image + operator_1.image + operand_2.image
	    			:	"";
	  }
 }

//(	  (operand_1=< INTEGER >|operand_1=< PL1_WORD >)
//      (operator_1=< PLUS >|operator_1=< MINUSCHAR >|operator_1=< DIVIDE >|operator_1=< MULTIPLY >)
//      ((math_expression())| (operand_2=< INTEGER >|operand_2=< PL1_WORD >))
//    )


void returns() #RETURNS:
{}
{
	< RETURNS >"(" type() ")"
}

void options() #OPTIONS:
{}
{
   < OPTIONS >"("((< MAIN >(< NOEXECOPS >)?)
   | (< ASSEMBLER >|< COBOL >|< FORTRAN >)
   | (< BYADDR >|< BYVALUE > )
   | (< NOCHARGRAPHIC >|< CHARGRAPHIC >)
   | (< NOCMPAT >|< CMPAT >)
   | (< DESCRIPTOR >|< NODESCRIPTOR >)
   | < FORMALIEN >
   | (< LINKAGE >parameterlist())
   | (< NOINLINE >|< INLINE >)
   | (< ORDER >|< REORDER >)
   | (< IRREDUCIBLE >| < REDUCABLE >)
   | < REETRANT >
   | < RETCODE >
   | < WINMAIN >)")"
}

void call() #CALLS:
{Token t = null;}
{
  < CALL >(t=< PL1_WORD >|< PL1_WORD >< BUILTIN >)("("(string_list()|parameterlist())")")?
	{
	  jjtThis.value = t.image;
	}
}

//TODO not fully implemented
void read_statement() #READ_FILE :
{
 // ArrayList<String > asignees = new ArrayList<String >();
  Token fileId;
  Token assignId;
  }
{
  < READ >< FILE >"("fileId=< PL1_WORD >")"< INTO > "("< PL1_WORD >")"

{
//  if(fileId != null)
//  {
//    asignees.add(fileId.image);
//  }
//  if(assignId != null) {
//	asignees.add(assignId.image);
//  }
  jjtThis.value = fileId.image;
}
}

void string_list() #STRINGLIST:
{Token t = null;}
{
  t=< STRING >(< COMMA_SEPARATOR >(string_list()|parameterlist()))?
  {
    jjtThis.value = t.image;
  }
}

void fetch() #FETCH:
{}
{(< FETCH >< PL1_WORD >)fetch_statement()
	
}

void fetch_statement() #STATEMENT:
{}
{    [< SET >"("< PL1_WORD >")"][< TITLE >"(""'"< PL1_WORD >"'"")"][< COMMA_SEPARATOR > fetch_statement()]
}

void release() #RELEASE:
{}
{
  < RELEASE >(< PL1_WORD >[< COMMA_SEPARATOR >])*
}

void termination() #TERMINATE:
{
  //TODO change to json
  ArrayList<String > terminationPropreties = new ArrayList<String >();
  Token returnType = null;
  Token returnValue = null;
  }
{
  (
  (returnType = < RETURN >[returnValue=< PL1_WORD >|("("parameterlist()")"|returnValue=< INTEGER >)|string_list()])
  |returnType = < GOTO >returnValue=< PL1_WORD >
  |returnType = < STOP >
  |returnType = < EXIT >)
  {
    terminationPropreties.add(returnType.image);
    if(returnValue != null) { 
    	terminationPropreties.add(returnValue.image);
   }
   else {
     terminationPropreties.add("");
   }
   jjtThis.value =  terminationPropreties;
  }
}

void parameterlist() #PARA :
{
  Token t;
  }
{
  t=< PL1_WORD >(< COMMA_SEPARATOR >(parameterlist()|string_list()))?

  {
    jjtThis.value = t.image;
  }
}


/**
* Grammar Expression for a Variable declaration.
**/
void var_declaration(int scope) #VAR :
{
  Token hierachie = null;
  this.scope = scope;}
{	  ( < DCL > | < DECLARE > ) 
	  (hierachie = < INTEGER >)?
	   { if(hierachie != null) { 
	     this.hierachie = Integer.parseInt(hierachie.image);
	   }
	     }
 	   id("VAR")
 	   ( type() [init_statement()]
 	   | type() < COMMA_SEPARATOR >
 	   | (< COMMA_SEPARATOR > minor(this.getHierachie(), scope))*
 	   )
 	   | minor(this.getHierachie(), scope)
     
}

/**
* Grammar Expression for a nested Variable Declaration.
**/
void minor(int parentHierachie, int scope) #MINOR :
{ Token hierachie;
  this.scope = scope;}
{
	hierachie = < INTEGER > id("VAR")
	{this.hierachie = Integer.parseInt(hierachie.image);
	 jjtThis.value = hierachie.image; }
	(type() |  type() < COMMA_SEPARATOR > | ( < COMMA_SEPARATOR > minor(this.getHierachie(), scope))*) 
}


/**
* Datatype of the Variabledeclaration.
**/
void type() #TYPE :
{}
{
	(	  codedArithmetic()
	  | String()
	  | (< POINTER > | < OFFSET > |  < HANDLE >) < VALUE >< LOCATES >
	  | Picture()
	  | File()
	  | < ENTRY > [< RETURNS >]
	) 
}

void File() #File :
{}
{
  < FILE > < ENVIRONMENT > [( < STREAM > | < RECORD >) (< INPUT > | < OUTPUT > | < UPDATE >)(<SEQUENTIAL >|  < DIRECT >) (< BUFFERED > | < UNBUFFERED >) < KEYED >< PRINT > ]
}

/**
* Grammar Expression for a Picture Expression.
**/
String Picture() #PictureExpression :
{ String t; }
{
  (( < PIC > | < PICTURE > ) | < WIDEPIC >) [< REAL > | < COMPLEX >] t = PictureAttribute() [< VALUE > ]
  {
	jjtThis.value = t;
    return pictureAttribiute = t; }
}


String PictureAttribute() #PictureAttribute:
{
 String t1 = "";
 String t11 = "";
 
 String t2 = "";
 String t22 = "";
 String t222 = "";
 String t2222 = "";
 
 String t3 = "";
 String t33 = "";
 String t333 = "";

 String t4 = "";

 String t5 = "";
 String t55 = "";
 }
{
  "'" (
	t1 = LengthPicture() (t11 = LetterPicture() | t11 = NumberPicture() ) |
	t2 = LetterPicture() ( t22 = NumberPicture() ( t222 = NumberPicture())*)? t2222 = LetterPicture()
	|	t3 = NumberPicture() t33 = LetterPicture() t333 = NumberPicture() |
	t4 = LetterPicture() |
	(t5 = NumberPicture() ( t55 = NumberPicture())*)?
     )"'"
     { if(t1 != "") return t1 + t11;
     	if(t2 != "") return t2 + t22 + t222 + t2222;
     	if(t3 != "") return t3 + t33 + t333;
     	if(t4 != "") return t4;
     	if(t5 != "") return t5 + t55;
     	 }
}

//| < PIC_REGEX : ("("["0"-"9"]")")?((["0"-"9","X"])+ |(["0"-"9","A"])+ |(["X","0"-"9"])+ )((["A"-"Z","0"-"9"])*) >

String LetterPicture() #PictureLetter :
{Token t;}
{
  ( t = < X > | t = < A > | t = < V >)
  {return t.toString();}
}

String NumberPicture() #Number :
{Token t;}
{
  t = < INTEGER >
  {return t.toString();}
}


String LengthPicture() #PictureLength:
{Token t;
 Token t1;
 Token t2;} 
{
  t = "(" t1 = < INTEGER > t2 = ")"
  {return t.toString() + t1.toString() + t2.toString(); }
}


/**
* Grammar Expression for a String Expression.
**/
void String() #String:
{
  Token length = null;
  }
{
  ( (< CHAR > | < CHARACTER >)
  | < BIT >
  |  < GRAPHIC >
  | < WIDECHAR >) ("(" length = < INTEGER > ")") [< NONVARYING >] [< VALUE >]
    {jjtThis.value = length.image; }
}


/**
* @todo change typeProprties to Map.
* Grammar Expression for a Arithmetic Datatype.
**/
void codedArithmetic() #Arithmetic:
{
  //TODO transfer to JSON
  typePropreties = new ArrayList<String >();

  Token typeAttribute = null;
  Token type = null;
  Token integerPropreties = null;
  Token fractionalPropreties = null;
  
  }
{
  [ < REAL >  | typeAttribute = < COMPLEX >  ]
  {
	if(typeAttribute != null) {
	  typePropreties.add( typeAttribute.image);
	}
  }
  [ < FLOAT > | typeAttribute = < FIXED >  ]
  {
    if(typeAttribute != null) {
	  typePropreties.add(typeAttribute.image);
	}
  }
  ( ( type = < BINARY > | type =< BIN > )
  | type = < DECIMAL >  )
  {
     if(type != null) {
	  typePropreties.add(type.image);
	}
  }
  ( [< PRECISION >]
  (("(" integerPropreties = < INTEGER > ")") | ("(" integerPropreties = < INTEGER > < COMMA_SEPARATOR > fractionalPropreties = <  INTEGER > ")"))) [< SIGNED > | < UNSIGNED > ]
  { if(fractionalPropreties == null) {
		typePropreties.add(integerPropreties.image);
  	}
  	else {
  		typePropreties.add(integerPropreties.image + "," + fractionalPropreties.image);
    }

    jjtThis.value = typePropreties;
  }
}

  
/**
* Grammar Expression for a  Identifier.
**/
void id(String type) #Id :
{
Token t;}
{
  t=<PL1_WORD>
  {
    //TODO To JSON
    String[] tmp = new String[4];
    switch(type) {
		case "VAR":
			tmp[0] = t.image;
			tmp[1] = this.getHierachie() + "";
			tmp[2] = this.scope + "";
			tmp[3] = "id";
			break;
			
		case "PROC":
			tmp[0] = t.image;
			tmp[1] = this.getHierachie() + "";
			tmp[2] = this.scope + "";
			tmp[3] = "proc";
			break;
			
		case "PACKAGE":
			tmp[0] = t.image;
			tmp[1] = this.getHierachie() + "";
			tmp[2] = "1";
			tmp[3] = "pack";
			break;
		default:
			tmp = null;
			break;
    }
    
	this.installIds(tmp);
	
	//Reset Hierachie and Scope
	setHierachie(DEFAULT);
	setScope(DEFAULT);
	jjtThis.value = tmp;
  }
}


